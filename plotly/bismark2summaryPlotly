#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long;
use FindBin qw($RealBin);
use lib "$RealBin/../lib";

## This program is Copyright (C) 2010-18, Felix Krueger <felix.krueger@babraham.ac.uk>
## and Phil Ewels <phil.ewels@scilifelab.se>

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details. 

## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.
my $bismark_version = '0.19.1_dev';

# Last modified 08 08 2018

my ($report_basename,$page_title,$verbose) = process_commandline();

sub process_commandline{
    my $help;
    my $version;
    my $title;
    my $manual_output_file;
    
    my $command_line = GetOptions ('help|man'              => \$help,
				   'o|basename=s'          => \$manual_output_file,
				   'title=s'               => \$title,
				   'version'               => \$version,
				   'verbose'               => \$verbose,
	);
    
    ### EXIT ON ERROR if there were errors with any of the supplied options
    unless ($command_line){
	die "Please respecify command line options\n";
    }
    
    ### HELPFILE
    if ($help){
	print_helpfile();
	exit;
    }
    
    if ($version){
	print << "VERSION";
	

                             Bismark HTML Summary Report

                           bismark2summary version: $bismark_version
                       Copyright 2010-18 Felix Krueger, Phil Ewels
                               Babraham Bioinformatics
                www.bioinformatics.babraham.ac.uk/projects/bismark/
                     https://github.com/FelixKrueger/Bismark



VERSION
		    exit;
    }
    unless (defined $title){
	$title = '';
    }
    unless (defined $manual_output_file){
	$manual_output_file = '';
    }
    

    return ($manual_output_file,$title,$verbose); 
}

sub print_helpfile{
  print <<EOF

  SYNOPSIS:

  This script uses Bismark report files of several samples in a run folder to generate a graphical summary HTML report as well as
  a whopping big table (tab delimited text) with all relevant alignment and methylation statistics which may be used for graphing
  purposes in R, Excel or the like. Unless specific BAM files are specified, bismark2summary first identifies Bismark BAM files in
  a folder (they need to use the Bismark naming conventions) and then automatically detects Bismark alignment, deduplication or
  methylation extractor (splitting) reports based on the input file basename. If splitting reports are found they overwrite the
  methylation statistics of the initial alignment report.


  USAGE: bismark2summary [options] [<BAM file(s)>]

  ARGUMENTS:

  BAM file(s)                 Optional. If no BAM files are specified explicitly the current working directory is scanned for 
                              Bismark alignment files and their associated reports. 

  OPTIONS:

  -o/--basename <filename>    Basename of the output file (optional). Generate a text file with all relevant extracted values
                              ('basename.txt') as well as an HTML report ('basename.html'). If not specified explicitly, the
                              the basename is 'bismark_summary_report'.

  --title <string>            Optional HTML report title; use --title "speech marks for text with spaces". Default: 
                              'Bismark Summary Report'. 			      


  --version                   Displays version information and exits.
			      
  --help                      Displays this help message and exits.


                                                Script last modified: 09 August 2018

EOF
    ;
  exit 1;
}


my $plotly_code  = read_report_template('plot.ly');
my $bismark_logo = read_report_template('bismark.logo');
my $bioinf_logo  = read_report_template('bioinf.logo');


#warn "Got Plot.ly:\n$plotly_code\n\n"; sleep(1);
#warn "Got Bismark logo:\n$bismark_logo\n\n"; sleep(1);
#warn "Got Bioinf:\n$bioinf_logo\n\n"; sleep(1);

sub read_report_template{
    my $template = shift;
    my $doc;
    warn "Attempting to open file from: $RealBin/$template\n" if ($verbose);
    open (DOC,"$RealBin/$template") or die "Failed to find file $template: $!";
    while(<DOC>){
	chomp;
	$_ =~ s/\r//g;
	$doc .= $_."\n";
    }
    
    close DOC or die $!;
    return $doc;
}


### AUTO-DETECTING BISMARK BAM FILES
my @bam_files = @ARGV; # user supplied BAM files
unless (@bam_files){
    my @detected_files;

    # If not user supplied we try to find BAM files automatically. Note that this will go horribly wrong if there were BAM files from another aligner in the same folder as well

    @detected_files = <*bismark_bt2.bam>; # SE Bowtie2
    if (@detected_files){
	warn "Found Bismark/Bowtie2 single-end files\n";
	push (@bam_files,@detected_files); # appending found files
	@detected_files = ();
    }
    else{
	warn "No Bismark/Bowtie2 single-end BAM files detected\n";
    }

    @detected_files = <*bismark_bt2_pe.bam>; # PE Bowtie2
    if (@detected_files){
	warn "Found Bismark/Bowtie2 paired-end files\n";
	push (@bam_files,@detected_files); # appending found files
	@detected_files = ();
    }
    else{
	warn "No Bismark/Bowtie2 paired-end BAM files detected\n"; 
    }
    
    @detected_files = <*bismark.bam>; # SE Bowtie1
    if (@detected_files){
	warn "Found Bismark/Bowtie single-end files\n";
	push (@bam_files,@detected_files); # appending found files
	@detected_files = ();
    }
    else{
	warn "No Bismark/Bowtie single-end BAM files detected\n";
    }	

    @detected_files = <*bismark_pe.bam>; # PE Bowtie
    if (@detected_files){
	warn "Found Bismark/Bowtie paired-end files\n";
	push (@bam_files,@detected_files); # appending found files
	@detected_files = ();
    }
    else{
	warn "No Bismark/Bowtie paired-end BAM files detected\n\n"; 
    }
}

if(scalar @bam_files == 0){
    die("Error: No Bismark BAM files found to generate a Bismark project summary. Please respecify...\n\nUSAGE:\nbismark2summary (*.bam), or bismark2summary --help for more information");
}
else {
    warn("Generating Bismark summary report from ",scalar @bam_files," Bismark BAM file(s)...\n");
}

unless ($report_basename){
    $report_basename = 'bismark_summary_report';
}
unless ($page_title){
    $page_title = 'Bismark Summary Report';
}

my @categories_arr;
my @not_aligned_arr;
my @aligned_arr;
my @ambig_aligned_arr;
my @no_seq_arr;
my @dup_alignments_arr;
my @unique_alignments_arr;
my @meth_cpg_string_arr;
my @unmeth_cpg_string_arr;
my @meth_chg_string_arr;
my @unmeth_chg_string_arr;
my @meth_chh_string_arr;
my @unmeth_chh_string_arr;

my @summary_csv_fields = (
    'File',
    'Total Reads',
    'Aligned Reads',
    'Unaligned Reads',
    'Ambiguously Aligned Reads',
    'No Genomic Sequence',
    'Duplicate Reads (removed)',
    'Unique Reads (remaining)',
    'Total Cs',
    'Methylated CpGs',
    'Unmethylated CpGs',
    'Methylated chgs',
    'Unmethylated chgs',
    'Methylated CHHs',
    'Unmethylated CHHs'
);

my $summary_csv = join("\t",@summary_csv_fields)."\n";
my $num_samples = scalar @bam_files;
for my $bam (@bam_files){

    # Set up variables
    my $base = substr($bam, 0, -4); # removes .bam from the end
    my $total_reads = '';
    my $aligned_reads = '';
    my $unaligned = '';
    my $ambig_reads = '';
    my $no_seq_reads = '';
    my $dup_reads = '';
    my $unique_reads = '';
    my $total_c = '';
    my $meth_cpg = '';
    my $unmeth_cpg = '';
    my $meth_chg = '';
    my $unmeth_chg = '';
    my $meth_chh = '';
    my $unmeth_chh = '';
    
    # Bismark report
    my $bm_report;
    my $paired_end = 0;

    if ($base =~ /_pe$/){
    	$base  =~ s/_pe$//;
    	$bm_report = $base."_PE_report.txt";
    	$paired_end = 1;
    } else {
        $bm_report = $base."_SE_report.txt";
    }

    ### Bismark reports are mandatory, deduplication or methylation extractor reports are optional
    if (-e $bm_report){ # 
	warn ">> Reading from Bismark report: $bm_report\n";
    } 
    else {
    	die "Could not find Bismark report ($bm_report) to open\n";
    }
    
    open (BISMARK_REPORT, "<", $bm_report) or warn "Warning! Couldn't read from Bismark report $bm_report: $!\n\n";	
    while(<BISMARK_REPORT>){
	chomp;
	if ($paired_end){
	    $total_reads = $1 if (/^Sequence pairs analysed in total:\s+(\d+)$/);
	    $unaligned = $1 if (/^Sequence pairs with no alignments under any condition:\s+(\d+)$/);
	    $ambig_reads = $1 if (/^Sequence pairs did not map uniquely:\s+(\d+)$/);
	    $no_seq_reads = $1 if (/^Sequence pairs which were discarded because genomic sequence could not be extracted:\s+(\d+)$/);
	    $aligned_reads = $1 if (/^Number of paired-end alignments with a unique best hit:\s+(\d+)$/);
	}
	else{
	    $total_reads = $1 if (/^Sequences analysed in total:\s+(\d+)$/);
	    $unaligned = $1 if (/^Sequences with no alignments under any condition:\s+(\d+)$/);
	    $ambig_reads = $1 if (/^Sequences did not map uniquely:\s+(\d+)$/);
	    $no_seq_reads = $1 if (/^Sequences which were discarded because genomic sequence could not be extracted:\s+(\d+)$/);
	    $aligned_reads = $1 if (/^Number of alignments with a unique best hit from the different alignments:\s+(\d+)$/);
	}

	$total_c = $1 if(/^Total number of C's analysed:\s+(\d+)$/);
	$meth_cpg = $1 if(/^Total methylated C's in CpG context:\s+(\d+)/);
	$meth_chg = $1 if(/^Total methylated C's in CHG context:\s+(\d+)/);
	$meth_chh = $1 if(/^Total methylated C's in CHH context:\s+(\d+)/);
	$unmeth_cpg = $1 if(/^Total unmethylated C's in CpG context:\s+(\d+)/);
	$unmeth_chg = $1 if(/^Total unmethylated C's in CHG context:\s+(\d+)/);
	$unmeth_chh = $1 if(/^Total unmethylated C's in CHH context:\s+(\d+)/);
	
    }
    # warn "'$total_c'\t'$meth_cpg'\t'$meth_chg'\t'$meth_chh'\t'$unmeth_cpg'\t'$unmeth_chg'\t'$unmeth_chh'\n";	
    close(BISMARK_REPORT) or warn "Failed to close filehandle BISMARK REPORT: $!\n\n";
    
    ### Deduplication report (optional)
    my $dedup;
    if ($paired_end){
        $dedup = $base."_pe.deduplication_report.txt";
    } 
    else {
        $dedup = $base.".deduplication_report.txt";
    }

    if(-e $dedup){
        open(DEDUP, "<", $dedup) or warn "Warning! Couldn't open deduplication report $dedup: $!\n\n";
		while(<DEDUP>){
			chomp;
			if(/^Total number of alignments analysed in .+:\s+(\d+)$/){
			$aligned_reads = $1;
			# warn "Setting aligned reads to $aligned_reads\n";
			}
			if(/^Total number duplicated alignments removed:\s+(\d+)/){
			$dup_reads = $1;
			# warn "Setting deduplicated reads to $dup_reads\n";
			}
			if(/^Total count of deduplicated leftover sequences:\s+(\d+)/){
			$unique_reads = $1;
			# warn "Setting unique reads to $unique_reads\n";
			}

		}
		close(DEDUP);
    }
    else{
	warn "No deduplication report present, skipping...\n";
    }
    
    ### Methylation Extraction report (optional)
    my $meth_extract;
    if ($paired_end){
        $meth_extract= $base."_pe.deduplicated_splitting_report.txt";
    }
    else{
        $meth_extract= $base.".deduplicated_splitting_report.txt";
    }
    
    if(-e $meth_extract){
        open(METHEXTR, "<", $meth_extract) or warn "Warning! Couldn't open methylation extractor report $meth_extract: $!\n";
		while(<METHEXTR>){
			chomp;
			$total_c = $1 if(/^Total number of C's analysed:\s+(\d+)$/);
			$meth_cpg = $1 if(/^Total methylated C's in CpG context:\s+(\d+)/);
			$meth_chg = $1 if(/^Total methylated C's in CHG context:\s+(\d+)/);
			$meth_chh = $1 if(/^Total methylated C's in CHH context:\s+(\d+)/);
			$unmeth_cpg = $1 if(/^Total C to T conversions in CpG context:\s+(\d+)/);
			$unmeth_chg = $1 if(/^Total C to T conversions in CHG context:\s+(\d+)/);
			$unmeth_chh = $1 if(/^Total C to T conversions in CHH context:\s+(\d+)/);
		}
		close(METHEXTR);
    }
    else{
		warn "No methylation extractor report present, skipping...\n";
    }

    my @csvrow = (
        $bam,
        $total_reads,
        $aligned_reads,
        $unaligned,
        $ambig_reads,
        $no_seq_reads,
        $dup_reads,
        $unique_reads,
        $total_c,
        $meth_cpg,
        $unmeth_cpg,
        $meth_chg,
        $unmeth_chg,
        $meth_chh,
        $unmeth_chh
    );
    $summary_csv .= join("\t", @csvrow)."\n"; # appending a new line every time
  
    my $name = $bam;
    $name =~ s/_bismark.bam$//;
    $name =~ s/\.fq\.gz$//;
    $name =~ s/_trimmed$//;
    $name =~ s/_[12]$//;

    $unaligned = 0      if $unaligned eq '';
    $ambig_reads = 0    if $ambig_reads eq '';
    $no_seq_reads = 0   if $no_seq_reads eq '';
    # if no deduplication has been performed we need to treat unique reads slighlty differently
    if ($dup_reads ne ''){
		$aligned_reads = "";
    }
    $meth_cpg = 0       if $meth_cpg eq '';
    $unmeth_cpg = 0     if $unmeth_cpg eq '';
    $meth_chg = 0       if $meth_chg eq '';
    $unmeth_chg = 0     if $unmeth_chg eq '';
    $meth_chh = 0       if $meth_chh eq '';
    $unmeth_chh = 0     if $unmeth_chh eq '';
    
    push(@categories_arr,          "'$name'");
    push(@aligned_arr,             $aligned_reads);
    push(@not_aligned_arr,         $unaligned);
    push(@ambig_aligned_arr,       $ambig_reads);
    push(@no_seq_arr,              $no_seq_reads);

    push(@dup_alignments_arr,      $dup_reads);
    push(@unique_alignments_arr,   $unique_reads);
    push(@meth_cpg_string_arr,     $meth_cpg);
    push(@unmeth_cpg_string_arr,   $unmeth_cpg);
    push(@meth_chg_string_arr,     $meth_chg);
    push(@unmeth_chg_string_arr,   $unmeth_chg);
    push(@meth_chh_string_arr,     $meth_chh);
    push(@unmeth_chh_string_arr,   $unmeth_chh);
    
    # warn "'$name'\t$unaligned\t$ambig_reads\t$no_seq_reads\t$dup_reads\t$unique_reads\t$meth_cpg\t$unmeth_cpg\t$meth_chg\t$unmeth_chg\t$meth_chh\t$unmeth_chh\n";sleep(1);
}

my $categories = join(",", @categories_arr);
my $aligned = join(",", @aligned_arr);
my $not_aligned = join(",", @not_aligned_arr);
my $ambig_aligned = join(",", @ambig_aligned_arr);
my $no_seq = join(",", @no_seq_arr);
my $dup_alignments = join(",", @dup_alignments_arr);
my $unique_alignments = join(",", @unique_alignments_arr);

my $meth_cpg_string   = join(",", @meth_cpg_string_arr);
my $unmeth_cpg_string = join(",", @unmeth_cpg_string_arr);
my $meth_chg_string   = join(",", @meth_chg_string_arr);
my $unmeth_chg_string = join(",", @unmeth_chg_string_arr);
my $meth_chh_string   = join(",", @meth_chh_string_arr);
my $unmeth_chh_string = join(",", @unmeth_chh_string_arr);



# Write the numeric data to a summary file
my $summary_fn = $report_basename.".txt";
open(SUMMARY_CSV, ">", $summary_fn) or die("Can't open $summary_fn: $!\n");
print SUMMARY_CSV $summary_csv;
close(SUMMARY_CSV);





# Write a nice HTML summary report
my $report_timestamp = localtime;
my $html_report = <<'HTMLTEMPLATESTRING';
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<title>Bismark Project Summary Report - {{page_title}}</title>
	<style type="text/css">
		body {
			font-family: Arial, sans-serif;
			font-size:14px;
			padding:0 20px 20px;
		}
		.container {
			margin:0 auto;
		}
		.header h1,
		.header img {
			float:left;
		}
		.header h1 {
			margin: 20px 0 10px;
		}
		.header img {
			padding: 0 20px 20px 0;
		}
		.subtitle {
			margin-top:120px;
			float:right;
			text-align:right;
		}
		.header_subtitle h3,
		.header_subtitle p {
			margin:0;
		}
		h1 {
			font-size: 3.2em;
		}
		h2 {
			font-size:2.2em;
		}
		h3 {
			font-size:1.4em;
		}
		h2, h3, hr {
			clear:both;
		}
		hr {
			border-top:1px solid #CCC;
			border-bottom:1px solid #F3F3F3;
			border-left:0;
			border-right:0;
			height:0;
		}
		.plot {
			width:100%;
			margin-bottom:0px;
            height: 350px;
		}
        .plot_meth{
            width:100%;
            margin-bottom:0px;
            margin-top: 0px;
            height:200px;
        }
		footer {
			color:#999;
		}
		footer a {
			color:#999;
		}
        .switch_group {
			margin-left:20px;
			display:inline-block;
			line-height: 1em;
		}
		.switch_group button {
			vertical-align:top;
			border: 1px solid #2f7ed8;
			border-left:0;
			background-color: #2f7ed8;
			color:#FFFFFF;
			padding: 8px;
			outline: none;
			cursor: pointer;
			-webkit-transition: background-color 150ms ease-in-out;
			-moz-transition: background-color 150ms ease-in-out;
			-o-transition: background-color 150ms ease-in-out;
			-ms-transition: background-color 150ms ease-in-out;
			transition: background-color 150ms ease-in-out;
		}
		.switch_group button:first-child {
			border-left: 1px solid #2f7ed8;
		}
		.switch_group button.active {
			background-color: #2f7ed8;
			color:#FFFFFF;
		}
	</style>

	<!-- Plotly.js -->
	{{plotly_goes_here}}
 	This will need to be replaced by the plot.ly library itself
 	{{plotly_goes_here}}
	
</head>
<body>


<div class="container">
	<div class="header">
		{{bismark_logo_goes_here}}
		<h1>Bismark Project Overall Summary</h1>
		<div class="subtitle">
			<h3>{{page_title}}</h3>
			<p>Report generated on {{report_timestamp}}</p>
		</div>
	</div>
	<hr>
	<h2>
		Alignment
		<div class="switch_group">
			<!-- <button id="version1">Number of Reads</button> <button id="version2">Percentages</button></div><div id="myData" style="width: 100%;"></div> -->
	</h2>
		
	<div id="alignmentPercentage" class="plot"><!-- Plotly chart will be drawn inside this DIV --></div>
	<div id="alignmentNumbers" class="plot"><!-- Plotly chart will be drawn inside this DIV --></div>
    <hr>
	<h2>
		Cytosine Methylation
	</h2>
        <div id="methylation_context_CpG" class="plot_meth"></div> 
        <div id="methylation_context_CHG" class="plot_meth"></div>
        <div id="methylation_context_CHH" class="plot_meth"></div>
	<hr>
	
	<!-- ### PLOT.LY CODE ##################################################################################################### -->

    <!-- ### ALIGNMENT SECTION -->

	<script>
		var alignment_plot_colors = ['#f28f43', '#0d233a', '#492970', '#2f7ed8', '#8bbc21'];
		var alignment_plot_colors2 = ['#01665e','#f28f43', '#0d233a', '#492970', '#2f7ed8', '#8bbc21'];	
		var meth_plot_colors = ['#0d233a', '#2f7ed8', '#8bbc21', '#1aadce', '#910000', '#492970'];
		var stacksDivPercentage = document.getElementById("alignmentPercentage");
        var stacksDivNumbers = document.getElementById("alignmentNumbers");
		var num_samples = {{num_samples}};
		
		var traces1 = [
			
			{x: [{{x_values_alignment}}], y: [{{aligned_seq}}],
				fill: 'tozeroy',
				name:'Raw Aligned Reads',
				fillcolor: '#01665e',
				visible: true,
                line:{
                    color: '#01665e',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
			},
			{x: [{{x_values_alignment}}], y: [{{no_seq}}],
				fill: 'tonexty',
				name:'No Genomic Sequence',
				fillcolor: '#f28f43',
                line:{
                    color: '#f28f43',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
			},
			{x: [{{x_values_alignment}}], y: [{{not_aligned}}],
				fill: 'tonexty',
				name:'Did Not Align',
				fillcolor: '#0d233a',
                line:{
                    color: '#0d233a',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
			},
			{x: [{{x_values_alignment}}], y: [{{ambig_aligned}}],
				name:'Aligned Ambiguously',
				fill: 'tonexty',
				fillcolor: '#492970',
                line:{
                    color: '#492970',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
			},
			{x: [{{x_values_alignment}}], y: [{{dup_alignments}}],
				name:'Duplicate Alignments', 
				fill: 'tonexty', 
				fillcolor: '#2f7ed8',
                line:{
                    color: '#2f7ed8',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
			},
			{x: [{{x_values_alignment}}], y: [{{unique_alignments}}],
				name:'Raw Unique Alignments',
				fill: 'tonexty', 
				fillcolor: '#8bbc21',
                line:{
                    color: '#8bbc21',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
			},
		];
	

		
        var traces2 = [
            
            {x: [{{x_values_alignment}}], y: [{{p_aligned_replace}}],
                fill: 'tozeroy',
                name:'Raw Aligned Reads',
                fillcolor: '#01665e',
                visible: true,
                line:{
                    color: '#01665e',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
            {x: [{{x_values_alignment}}], y: [{{p_no_seq_replace}}],
                fill: 'tonexty',
                name:'No Genomic Sequence',
                fillcolor: '#f28f43',
                line:{
                    color: '#f28f43',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
            {x: [{{x_values_alignment}}], y: [{{p_unal_replace}}],
                fill: 'tonexty',
                name:'Did Not Align',
                fillcolor: '#0d233a',
                line:{
                    color: '#0d233a',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
            {x: [{{x_values_alignment}}], y: [{{p_ambig_replace}}],
                name:'Aligned Ambiguously',
                fill: 'tonexty',
                fillcolor: '#492970',
                line:{
                    color: '#492970',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
        ];

		function stackedArea(traces) {
			var i, j;
			for(i=0; i<traces.length; i++) {
				traces[i].text = [];
				traces[i].hoverinfo = 'text+name';
				for(j=0; j<(traces[i]['y'].length); j++) {
					traces[i].text.push(traces[i]['y'][j].toFixed(0));
				}
			}
			for(i=1; i<traces.length; i++) {
				for(j=0; j<(Math.min(traces[i]['y'].length, traces[i-1]['y'].length)); j++) {
					traces[i]['y'][j] += traces[i-1]['y'][j];
				}
			}
			return traces;
		}
		
		var layoutNumbers = {
			xaxis: {
				titlefont: {
					size: 14,
					color: '#4d759e',
				},
                showgrid: false,
                title: '<b>Sample [Hover to identify Sample and Numbers]</b>',
			},
             margin: {
                l: 50,
                r: 20,
                b: 40,
                t: 0, 
                pad: 0,           
            },
			yaxis: {
				title: '<b># Reads</b>',
				titlefont: {
					size: 14,
					color: '#4d759e',
				}
			},
			legend:{
				x: 0.4,
				y: 1.05,
				orientation: 'h',
			}				
		}
        var layoutPercentage = {
            xaxis: {
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                },
                showgrid: false,
            },
             margin: {
                l: 50,
                r: 20,
                b: 40,
                t: 0,
                pad: 0,
            },
            yaxis: {
                title: '<b>% of all Reads</b>',
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                }
            },
            legend:{
                x: 0.4,
                y: 1.05,
                orientation: 'h',
            },
        }


         Plotly.newPlot(stacksDivPercentage, stackedArea(traces2), layoutPercentage,
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
            );
        Plotly.newPlot(stacksDivNumbers, stackedArea(traces1), layoutNumbers,
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
            );
        document.getElementById('version1').addEventListener('click', function() {
            Plotly.newPlot(stacksDivNumbers, stackedArea(traces1), layout,
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
            );
            <!-- document.getElementById('myData').innerHTML = JSON.stringify(traces1); -->
        })
        document.getElementById('version2').addEventListener('click', function() {
            Plotly.newPlot(stacksDivPercentage, stackedArea(traces2), layout2, 
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
            );
            <!-- document.getElementById('myData').innerHTML = JSON.stringify(traces2); -->
        })

        
			
	</script>

    <!-- ### METHYLATION CONTEXT -->

    <script>
        var alignment_plot_colors2 = ['#01665e','#f28f43', '#0d233a', '#492970', '#2f7ed8', '#8bbc21']; 
        var meth_plot_colors = ['#0d233a', '#2f7ed8', '#8bbc21', '#1aadce', '#910000', '#492970'];
        var methylationDiv_CpG = document.getElementById("methylation_context_CpG");

        var methylationDiv_CHG = document.getElementById("methylation_context_CHG");

        var methylationDiv_CHH = document.getElementById("methylation_context_CHH");

        var num_samples = {{num_samples}};
        
        <!-- CpG methylation calls -->
        var traces_m1 = [ 
            <!-- {x: [{{x_values_methylation}}], y: [{{meth_cpg_string}}], -->
            {x: [{{x_values_methylation}}], y: [{{p_CpG_m_replace}}], 
                fill: 'tozeroy',
                name:'Methylated CpG',
                fillcolor: '#0d233a',
                visible: true,
                line:{
                    color: '#0d233a',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
            <!-- {x: [{{x_values_methylation}}], y: [{{unmeth_cpg_string}}], -->
            {x: [{{x_values_methylation}}], y: [{{p_CpG_u_replace}}], 
                fill: 'tonexty',
                name:'Unmethylated CpG',
                fillcolor: '#2f7ed8',
                line:{
                    color: '#2f7ed8',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
        ];

        <!-- CHG methylation calls -->
        var traces_m2 = [ 
            <!-- {x: [{{x_values_methylation}}], y: [{{meth_chg_string}}], -->
            {x: [{{x_values_methylation}}], y: [{{p_CHG_m_replace}}], 
                fill: 'tozeroy',

                name:'Methylated CHG',
                fillcolor: '#1aadce',
                visible: true,
                line:{
                    color: '#1aadce',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
            <!-- {x: [{{x_values_methylation}}], y: [{{unmeth_chg_string}}], -->
            {x: [{{x_values_methylation}}], y: [{{p_CHG_u_replace}}], 
                fill: 'tonexty',
                name:'Unmethylated CHG',
                fillcolor: '#8bbc21',
                line:{
                    color: '#8bbc21',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
            },
        ];

         <!-- CHH methylation calls -->
        var traces_m3 = [ 
            <!-- {x: [{{x_values_methylation}}], y: [{{meth_chh_string}}],  -->
                {x: [{{x_values_methylation}}], y: [{{p_CHH_m_replace}}], 
                fill: 'tozeroy',
                line:{
                    color: '#492970',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
                name:'Methylated CHH',
                fillcolor: '#492970',
                visible: true,
            },
            <!-- {x: [{{x_values_methylation}}], y: [{{unmeth_chh_string}}],  -->
                {x: [{{x_values_methylation}}], y: [{{p_CHH_u_replace}}], 
                fill: 'tonexty',
                line:{
                    color: '#910000',
                    width: 1,
                },
                marker:{
                    symbol: 'circle-dot',
                    size: 7,
                    line:{
                        color: 'black',
                        width:1,
                    },
                },
                name:'Unmethylated CHH',
                fillcolor: '#910000',
            },
        ];

        function stackedArea(traces) {
            var i, j;
            for(i=0; i<traces.length; i++) {
                traces[i].text = [];
                traces[i].hoverinfo = 'text+name';
                for(j=0; j<(traces[i]['y'].length); j++) {
                    traces[i].text.push(traces[i]['y'][j].toFixed(0));
                }
            }
            for(i=1; i<traces.length; i++) {
                for(j=0; j<(Math.min(traces[i]['y'].length, traces[i-1]['y'].length)); j++) {
                    traces[i]['y'][j] += traces[i-1]['y'][j];
                }
            }
            return traces;
        }
        
        var layoutReads = {
            xaxis: {
                title: '<b>Sample [Hover to identify Sample and Numbers]</b>',
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                }
                
            },
            yaxis: {
                title: '<b># Methylation Calls</b>',
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                }
            },
            height: 400,
            legend:{
                x: 0.45,
                y: 1.1,
                orientation: 'h',
            }               
        }
        var layoutCpG = {
            <!--title: '<b>Sample [Hover to identify Sample and Numbers]</b>',-->
            yaxis: {
                title: '<b>% CpG Calls</b>',
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                }
            },
            margin: {
                l: 50,
                r: 20,
                b: 20,
                t: 0,
                pad: 0,
            },
            legend:{
                x: 0.8,
                y: 0.9,
                orientation: 'h',
            }               
        }

         var layoutCHG = {
            <!--title: '<b>Sample [Hover to identify Sample and Numbers]</b>',-->
            yaxis: {
                title: '<b>% CHG Calls</b>',
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                }
            },
            margin: {
                l: 50,
                r: 20,
                b: 20,
                t: 0,
                pad: 0,
            },
            legend:{
                x: 0.8,
                y: 0.9,
                orientation: 'h',
            }               
        }

         var layoutCHH = {
            <!--title: '<b>Sample [Hover to identify Sample and Numbers]</b>',-->
            yaxis: {
                title: '<b>% CHH Calls</b>',
                titlefont: {
                    size: 14,
                    color: '#4d759e',
                }
            },
            margin: {
                l: 50,
                r: 20,
                b: 20,
                t: 0,
                pad: 0,
            },
            legend:{
                x: 0.8,
                y: 0.9,
                orientation: 'h',
            }               
        }
      
        Plotly.newPlot(methylationDiv_CpG, stackedArea(traces_m1), layoutCpG,
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
        );
                Plotly.newPlot(methylationDiv_CHG, stackedArea(traces_m2), layoutCHG,
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
        );
        Plotly.newPlot(methylationDiv_CHH, stackedArea(traces_m3), layoutCHH,
                                        {displaylogo: false},
                                        {modeBarButtonsToRemove:
                                        ['toImage',
                                        'sendDataToCloud',
                                        'resetScale2d',
                                        'hoverClosestCartesian',
                                        'hoverCompareCartesian',
                                        'toggleSpikelines']
                                        },
        );
        
            
    </script>
	
	<footer>
		<a style="float:right;" href="https://www.bioinformatics.babraham.ac.uk/">
            {{bioinf_logo_goes_here}}
		</a>

		<p>Analysis produced by <a href="http://www.bioinformatics.babraham.ac.uk/projects/bismark/"><strong>Bismark</strong></a> (version {{bismark_version}}) - a tool to map bisulfite converted sequence reads and determine cytosine methylation states</p>
		
		<p>Report graphs rendered using <a href="https://plot.ly/">plot.ly</a>, design last changed 08 Aug 2018. Summary script and page design by <a href="https://www.babraham.ac.uk/science-services/bioinformatics/simon-andrews/members/191/felix-krueger">Felix Krueger</a> and <a href="http://phil.ewels.co.uk/">Phil Ewels</a> </p>

	</footer>
</div>
</body>
</html>
HTMLTEMPLATESTRING



### Put in our variables
# replacing the Plot.ly spaceholders with the actual plot.ly code
if ($html_report =~ s/\{\{plotly_goes_here\}\}.*\{\{plotly_goes_here\}\}/$plotly_code/s){
    warn "Plot.ly injection successful!\n" if $verbose;
}
else{
	die "Plot.ly injection not working, won't be able to construct any meaningful HTML reports in this case....\n\n";
}
$html_report =~ s/\{\{bismark_logo_goes_here\}\}/$bismark_logo/;
$html_report =~ s/\{\{bioinf_logo_goes_here\}\}/$bioinf_logo/;
$html_report =~ s/\{\{report_timestamp\}\}/$report_timestamp/g;
$html_report =~ s/\{\{page_title\}\}/$page_title/g;



$html_report =~ s/\{\{num_samples\}\}/$num_samples/g;
# Calculating X Coordinates
my @x_values;
for (1..$num_samples){
	push @x_values, $_;
}
my $x_values = join (",",@x_values);
$html_report =~ s/\{\{x_values_alignment\}\}/$x_values/g;
$html_report =~ s/\{\{x_values_methylation\}\}/$x_values/g;
print "Number of samples: $num_samples\n" if $verbose;
print "X-coords: $x_values\n" if $verbose;

$html_report =~ s/\{\{categories\}\}/$categories/g;
print "Categories: $categories\n" if $verbose;
$html_report =~ s/\{\{bismark_version\}\}/$bismark_version/g;

####################################################################################
###  ALIGNMENT SECTION
####################################################################################

print "ALIGNMENT SECTION\n=================\n" if $verbose;
if ($aligned =~ /^,{1,}$/){
	warn "$aligned contained only commas. Setting it to empty string\n" if $verbose;	
	$aligned = '';	
}
else{
	warn ">$aligned< contained other elements than  commas as well\n" if $verbose;	
}	
$html_report =~ s/\{\{aligned_seq\}\}/$aligned/g;
print "Aligned: $aligned\n" if $verbose;

$html_report =~ s/\{\{no_seq\}\}/$no_seq/g;
print "No Seq: $no_seq\n" if $verbose;
$html_report =~ s/\{\{not_aligned\}\}/$not_aligned/g;
print "Not Aligned: $not_aligned\n" if $verbose;
$html_report =~ s/\{\{ambig_aligned\}\}/$ambig_aligned/g;
print "Ambiguous Aligned: $ambig_aligned\n" if $verbose;

### DEDUPLICATED ALIGNMENTS
if ($dup_alignments =~ /^,{1,}$/){
	warn "$dup_alignments contained only commas. Setting it to empty string\n" if $verbose;	
	$dup_alignments = '';	
}
else{
	warn ">$dup_alignments< contained other elements than  commas as well\n" if $verbose;	
}	
$html_report =~ s/\{\{dup_alignments\}\}/$dup_alignments/g;
print "Duplicated alignments: $dup_alignments\n" if $verbose;

### UNIQUE DEDUPLICATED ALIGNMENTS
if ($unique_alignments =~ /^,{1,}$/){
	warn "$unique_alignments contained only commas. Setting it to empty string\n" if $verbose;	
	$unique_alignments = '';	
}
else{
	warn ">$unique_alignments< contained other elements than  commas as well\n" if $verbose;	
}	
$html_report =~ s/\{\{unique_alignments\}\}/$unique_alignments/g;
print "Unique Alignments: $unique_alignments\n" if $verbose;

### Calculating percentages
my @perc_aligned;
if ($aligned){
	warn "Found raw, undeduplicated unique aligments. Using those...\n" if $verbose;
	@perc_aligned = split (/,/,$aligned);
}
if ($unique_alignments){
	warn "Found deduplicated unique aligments. Using those...\n" if $verbose;
	@perc_aligned = split (/,/,$unique_alignments);
}	
print "Aligned:\t",join (" ~~ ",@perc_aligned),"\n" if $verbose;

my @perc_not_aligned = split (/,/,$not_aligned);
print "Not Aligned:\t",join (" ~~ ",@perc_not_aligned),"\n" if $verbose;

my @perc_no_seq = split (/,/,$no_seq);
print "No Sequence:\t",join (" ~~ ",@perc_no_seq),"\n" if $verbose;

my @perc_ambig_aligned = split (/,/,$ambig_aligned);
print "Ambiguous:\t",join (" ~~ ",@perc_ambig_aligned),"\n" if $verbose;


my @p_aligned;
my @p_not_aligned;
my @p_no_seq;
my @p_ambig_aligned;

### Calculating percentages for the Alignment graph
foreach my $index (0..$#perc_aligned){
    my $total = $perc_aligned[$index] + $perc_no_seq[$index] + $perc_not_aligned[$index] +$perc_ambig_aligned[$index];
    # warn "Aligned: $perc_aligned[$index]\nNo Seq: $perc_no_seq[$index]\nNot Aligned: $perc_not_aligned[$index]\nAmbig: $perc_ambig_aligned[$index]\nTotal: $total\n~~~~~~~~\n\n";
    my $p_al     = sprintf("%.2f", $perc_aligned[$index] / $total * 100);
    my $p_no_seq = sprintf("%.2f", $perc_no_seq[$index] / $total * 100);
    my $p_unal   = sprintf("%.2f", $perc_not_aligned[$index] / $total * 100);
    my $p_ambig  = sprintf("%.2f", $perc_ambig_aligned[$index] / $total * 100);

    if ($verbose){
        print "Aligned: $perc_aligned[$index] ($p_al%)\n";
        print "No Seq:  $perc_no_seq[$index] ($p_no_seq%)\n";
        print "Not Aligned: $perc_not_aligned[$index] ($p_unal%)\n";
        print "Ambiguous Aligned: $perc_ambig_aligned[$index] ($p_ambig%)\n";
        print "Total: $total\n\n";
    }  
    push @p_aligned,       $p_al;
    push @p_not_aligned,   $p_unal;
    push @p_no_seq,        $p_no_seq;
    push @p_ambig_aligned, $p_ambig;
}


### Replacing in the HTML template
print "Aligned:\t",       join ("\t", @p_aligned),"\n" if $verbose;
print "Unaligned:\t",     join ("\t", @p_not_aligned),"\n" if $verbose;
print "No Seq:\t\t",      join ("\t", @p_no_seq),"\n" if $verbose;
print "Ambig Aligned:\t", join ("\t", @p_ambig_aligned),"\n" if $verbose;

my $p_aligned_replace = join (",", @p_aligned);
my $p_unal_replace    = join (",", @p_not_aligned);
my $p_no_seq_replace  = join (",", @p_no_seq);
my $p_ambig_replace   = join (",", @p_ambig_aligned);

warn "$p_aligned_replace\n$p_unal_replace\n$p_no_seq_replace\n$p_ambig_replace\n\n";

$html_report =~ s/\{\{p_aligned_replace\}\}/$p_aligned_replace/;
$html_report =~ s/\{\{p_no_seq_replace\}\}/$p_no_seq_replace/;
$html_report =~ s/\{\{p_unal_replace\}\}/$p_unal_replace/;
$html_report =~ s/\{\{p_ambig_replace\}\}/$p_ambig_replace/;


#################################################################
### METHYLATION CONTEXT SECTION
#################################################################

print "METHYLATION CONTEXT SECTION\n===========================\n" if $verbose;
$html_report =~ s/\{\{meth_cpg_string\}\}/$meth_cpg_string/g;
print "  Meth CpG:\t$meth_cpg_string\n" if $verbose;
$html_report =~ s/\{\{unmeth_cpg_string\}\}/$unmeth_cpg_string/g;
print "Unmeth CpG:\t$unmeth_cpg_string\n" if $verbose;
$html_report =~ s/\{\{meth_chg_string\}\}/$meth_chg_string/g;
print "  Meth CHG:\t$meth_chg_string\n" if $verbose;
$html_report =~ s/\{\{unmeth_chg_string\}\}/$unmeth_chg_string/g;
print "Unmeth CHG:\t$unmeth_chg_string\n" if $verbose;
$html_report =~ s/\{\{meth_chh_string\}\}/$meth_chh_string/g;
print "  Meth CHH:\t$meth_chh_string\n" if $verbose;
$html_report =~ s/\{\{unmeth_chh_string\}\}/$unmeth_chh_string/g;
print "Unmeth CHH:\t$unmeth_chh_string\n\n" if $verbose;


my @p_CpG_m;
my @p_CpG_u;
my @p_CHG_m;
my @p_CHG_u;
my @p_CHH_m;
my @p_CHH_u;

### Calculating percentages for the Methylation Conntext graph
foreach my $index (0..$#meth_cpg_string_arr){

    my $total_CpG = $meth_cpg_string_arr[$index] + $unmeth_cpg_string_arr[$index];
    my $total_CHG = $meth_chg_string_arr[$index] + $unmeth_chg_string_arr[$index];  
    my $total_CHH = $meth_chh_string_arr[$index] + $unmeth_chh_string_arr[$index];

    my $p_CpG_meth   = sprintf("%.2f",$meth_cpg_string_arr[$index] / $total_CpG * 100);
    my $p_CpG_unmeth = 100 - $p_CpG_meth;
    my $p_CHG_meth   = sprintf("%.2f",$meth_chg_string_arr[$index] / $total_CHG * 100);
    my $p_CHG_unmeth = 100 - $p_CHG_meth;
    my $p_CHH_meth   = sprintf("%.2f",$meth_chh_string_arr[$index] / $total_CHH * 100);
    my $p_CHH_unmeth = 100 - $p_CHH_meth;   

    if ($verbose){
        print "Meth CpG:   $meth_cpg_string_arr[$index] ($p_CpG_meth%)\n";
        print "Unmeth CpG: $unmeth_cpg_string_arr[$index] ($p_CpG_unmeth%)\n";
        
        print "Meth CHG:   $meth_chg_string_arr[$index] ($p_CHG_meth%)\n";
        print "Unmeth CHG: $unmeth_chg_string_arr[$index] ($p_CHG_unmeth%)\n";

        print "Meth CHH:   $meth_chh_string_arr[$index] ($p_CHH_meth%)\n";
        print "Unmeth CHH: $unmeth_chh_string_arr[$index] ($p_CHH_unmeth%)\n";

        print "Total CpG: $total_CpG\n";
        print "Total CHG: $total_CHG\n";
        print "Total CHH: $total_CHH\n\n";

    }  
    push @p_CpG_m, $p_CpG_meth;
    push @p_CpG_u, $p_CpG_unmeth;
    push @p_CHG_m, $p_CHG_meth;
    push @p_CHG_u, $p_CHG_unmeth;
    push @p_CHH_m, $p_CHH_meth;
    push @p_CHH_u, $p_CHH_unmeth;
}

### Replacing in the HTML template

my $p_CpG_m_replace = join (",", @p_CpG_m);
my $p_CpG_u_replace = join (",", @p_CpG_u);
my $p_CHG_m_replace = join (",", @p_CHG_m);
my $p_CHG_u_replace = join (",", @p_CHG_u);
my $p_CHH_m_replace = join (",", @p_CHH_m);
my $p_CHH_u_replace = join (",", @p_CHH_u);


warn "$p_CpG_m_replace\n$p_CpG_u_replace\n$p_CHG_m_replace\n$p_CHG_u_replace\n$p_CHH_m_replace\n$p_CHH_u_replace\n\n" if $verbose;

$html_report =~ s/\{\{p_CpG_m_replace\}\}/$p_CpG_m_replace/;
$html_report =~ s/\{\{p_CpG_u_replace\}\}/$p_CpG_u_replace/;
$html_report =~ s/\{\{p_CHG_m_replace\}\}/$p_CHG_m_replace/;
$html_report =~ s/\{\{p_CHG_u_replace\}\}/$p_CHG_u_replace/;
$html_report =~ s/\{\{p_CHH_m_replace\}\}/$p_CHH_m_replace/;
$html_report =~ s/\{\{p_CHH_u_replace\}\}/$p_CHH_u_replace/;



# Write the HTML report to disk
my $html_fn = "${report_basename}.html";
open(SUMMARY_HTML, ">", $html_fn) or die("Can't open $html_fn: $!\n");
print SUMMARY_HTML $html_report;
close(SUMMARY_HTML) or warn "Failed to close fh: $!\n";

warn("\nWrote Bismark project summary to >> $html_fn <<\n\n");
